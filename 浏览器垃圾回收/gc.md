## gc

#### 内存分配

* 基本数据类型，存放在栈内存中，占用固定大小的内存，我们可以按照值来访问
* 引用数据类型，他的地址存放在栈内存中，但是数据是存放在堆内存中，而且大小是不固定

> 为什么会有堆栈内存呢，这就要说到js的垃圾回收机制了，哪为什么会有垃圾回收呢，当然是为了节约内存，加快运行速度，防止内存的溢出和系统的崩溃

* 当一个方法运行的时候，会有部门内存用来存放方法中定义的变量，这写变量存放在栈内存中，当方法执行完的时候，会释放方法中变量（引用地址除外），然后被垃圾回收，销毁

* 但当我们声明一个对象的时候，这个对象在其他地方也有可能被引用，并且他的大小也不是固定的，会被存放在堆内存中，随着方法的结束，堆内存也不会被销毁，因为其他的地方还在引用，除非这个引用的位置为0


#### 内存的泄漏

* 什么情况下会内存泄漏?可以这么理解，就是有些代码本来应该要被回收的，但是没有被回收，所以一直占用着操作系统的内存，从而越积越多。一般的内存泄漏其实无关紧要，可怕的是内存泄漏引起的堆积，导致GC一直没办法使用所占用的内存给其他程序使用。

##### 引起内存泄漏的情况

1. 意外的全局变量
```js
function golob(){
  this.bar = '123'
}

//解决的方法
window.bar = null
delete window.bar
```

2. 被遗忘的定时器和回调函数 ----->解决的方法：手动清除定时器

3. 闭包

   ```js
   var someResource = getData();
   setInterval(function() {
    var node = document.getElementById('Node');
       if(node) {
        node.innerHTML = JSON.stringify(someResource));
           // 定时器也没有清除
       }
       // node、someResource 存储了大量数据 无法回收
   }, 1000);
   
   ```
   

4. 没有清理的dom元素

   ```js
     var refA = document.getElementById('refA');
     document.body.removeChild(refA); // dom删除了
     console.log(refA, "refA");  // 但是还存在引用 能console出整个div 没有被回收
   ```

#### 内存的溢出

* 是指我们在申请内存使用的时候，分配的内存比我们申请的要小

#### js垃圾回收机制

### 标记清除

> 当我们的变量进入内存中的时候，都会增加一个标记，当我们使用的时候，这个标记会被清除掉，而当浏览器的垃圾回收进行的时候他们会自动的把这些标记的给回收掉

### 引用计数（淘汰掉的算法）

> 循环引用：跟踪记录每个值被引用的技术