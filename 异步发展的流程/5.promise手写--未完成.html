<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    //Es5实现
    //注意点 
    //1. 回调函数是立即执行；
    //1-1. 状态值能从pending->resolve或者从pendding->reject
    //2. 在什么时候调用成功和失败的函数，是使用者说了算。
    //3. then这个方法，其实就是传递了两个回调函数。
    function MyPromise(task) { //我们默认的promise是传递一个函数的，而且函数是立即执行的可能这个函数里面执行是同步也是异步的。
      let that = this
      this.value = undefined
      this.reason = undefined
      this.status = "pending" //这个是状态，因为有可能task里面是异步执行的
      this.onFullfailFn = []
      this.onRejectFn = []

      function resolve(value) { //请求成功的时候要执行的方法--->我们请求成功执行的时候，可能会传递参数
        //执行的时候我们要判断一下现在的状态。／只有是异步pending的时候我们才来执行此方法
        if (that.status == "pending") {
          //如果执行到这里面，状态肯定要改变的
          that.status = "resolve"
          that.value = value
          //同时如果异步成功来，肯定需要有回调的函数来执行---->回调哪里来的，通过then方法传递过来的
          that.onFullfailFn.forEach(cb => cb(that.value));
        }
      }

      function reject(reason) { //请求失败的时候要执行的方法
        if (that.status == "pending") {
          //如果执行到这里面，状态肯定要改变的
          that.status = "reject"
          that.reason = reason
          //同时如果异步成功来，肯定需要有回调的函数来执行---->回调哪里来的，通过then方法传递过来的
          //如果是同步那么that.onRejectFn为空，如果是异步那么他才会有值。
          that.onRejectFn.forEach(cb => cb(that.reason));
        }
      }
      try {
        task(resolve, reject) //task 里面传递两个函数，在成功或者失败的时候来执行
      } catch (e) {
        reject(e); //reject 是定义在这的私有方法
      }
    }

    MyPromise.prototype.then = function(onFullfail, onReject) { //then里面则需要定义两个方法，在异步pending的时候要传递给给到reject里面并且，在reject或者resolve的时候来执行。
      //在这里我们也要进行一个判断，如果是异步且是pending，我们才会添加此方法，如果是是直接成功态，或者失败态，我们都直接去执行
      let that = this
      let promise2;
      if (this.status == "pending") {
        this.onFullfailFn.push(function() {
          let x = onFullfail(that.value)
          resolvePromise(promise2, x, reslove, reject);
        });
        this.onRejectFn.push(function() {
          let x = onReject(that.value)
          resolvePromise(promise2, x, reslove, reject);
        });
      }
      //如果是同步---分为两种情况，直接成功或者直接失败
      if (this.status == "resolve") { //如果是同步，执行then方法的时候，我们直接去可以判断status的状态来确定走那边。
        return promise2 = new MyPromise((reslove, reject) => { //这是用来继续then的
          let x = onFullfail(that.value);
          // 如果x这个返回值存在那么就走下面
          resolvePromise(promise2, x, reslove, reject);
        })
      }
      if (this.status == "reject") { //如果是同步，那么就是直接让resolve或者reject执行了
        let x = onFullfail(that.reason)
        resolvePromise(promise2, x, reslove, reject);
      }
    }

















    //promise
    function fn() {
      return new MyPromise((resolve, reject) => {
        resolve("xx")
        // setTimeout(() => {
        //   if (Math.random() > 0.5) {
        //     resolve("succese")
        //   } else {
        //     reject("faild")
        //   }
        // }, 2000)
      })
    }
    var p = fn();
    p.then(function(value) {
      console.log(value)
    }, function(err) {
      console.log(err)
    })
  </script>
</body>

</html>