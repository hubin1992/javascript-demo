<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    //generator--->生成器（生成器的作用就是生成一个迭代器）
    //1. 根普通函数的区别 在function关键字之间多了一个*
    //2. 他不会主动的去执行，必须需要next()去激活才会执行
    //3. yield 相当于一个拦截器，如果我们不用next去激活，他到yield自动停止
    //4. 返回的是一个对象，{value（yield值）,done:状态}
    function* get(a) {
      console.log(1); //默认是不会执行的
      let b = yield a ;//如果是个常量"a"那么没办法修改
      let c = yield b
      return 'end'
    }
    // 未传参数--->当我们第一次执行next的时候，如果未传递参数，那么就相当执行了第一个yield然后return a，我们定义的b变量其实是用来传递参数的。传递给下一个yid
    /* var a = get();
    console.log(a.next()); //{value: "a", done: false}
    console.log(a.next()); //{value: "b", done: false}
    console.log(a.next()); //{value: "end", done: true} */

    //传递参数
    let a  = get("这是给a的")
    console.log(a.next("看一下是否能传递给b"));//{value: "这是给a的", done: false},所有的第一个next如果传递值是无效的。
    console.log(a.next("这个是传递给b的"));//{value: "这个是传递给b的", done: false}
    console.log(a.next());//{value: "end", done: true} 我们是返回了一个常量，也可以是变量


    //es5去实现生成器
    // function read(books) {
    //   let num = 0
    //   return {
    //     next() {
    //       let value = books[num] ? books[num] : undefined
    //       num++
    //       let done = num == books.length
    //       return {
    //         value,
    //         done
    //       }
    //     }
    //   }
    // }

    // var r = read(['js', 'node'])
    // console.log(r)
    // console.log(r.next()); //{value: "js", done: false}
    // console.log(r.next()); //{value: "node", done: true}
    // console.log(r.next()); //{value: undefined, done: false}
  </script>
</body>

</html>