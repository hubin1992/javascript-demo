<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <script>

        //线程和进程的区别
        // 进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。以前进程既是资源分配也是调度的最小单位，后来为了更合理的使用cpu(实际上是cpu性能越来越好)，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。

        // js为什么是单线程；
        // js主要是用来做一些交互和操作dom，假如说，js是多线程的，那么如果两个线程同时来操作dom，一个删掉，一个添加，那么我应该先执行那个，所以说注定了他是要单线程

        //浏览器是一个多线程，她最少有三个线程在同时工作，一个运行js脚本的线程（js是单线程的，一值在等着任务队列中的任务到来，然后进行处理），一个gui渲染的线程（当js重回或者回流的时候，需要重新渲染就会执行这个线程），还有一个浏览器的事件触发线程（当浏览器事件触发了，然后会把其添加到任务队列的队尾，等待js引擎的处理）

        //chrome浏览器中，为了防止因为一个页面崩溃而引起浏览器崩溃，所以他的每一个选项卡都是一个进程；


        /*
            //js中的同步编程和异步编程
            同步：上一件事情没完成，继续做上一件，只有完成上一件才会做下一件js中大部分都是同步编程---》执行在主线程上的；
        */
        var n = 0;
        while (1) {

        }
        console.log(n); //n 不会执行，因为while是个死循环；典型的异步编程的例子


        //异步：多件事情共同执行----》排进任务队列，当主线程通知任务队列那个可以执行了，该任务进入主线程，进行执行；
        //    定时器、事件、ajax、回调函数


        var n = 0;
        setTimeout(function () {
            n += 2;
            console.log(n);//7
        }, 10);

        setTimeout(function(){
            n+=5;
            console.log(n);//5(3)
        },6)
        console.log(n);//0 (1)
        for(var i = 0;i<999;i++){

        }
        console.log(n);//0 (2)


        //解析
        // 两个定时器是异步编程--》所以限制性异步的下面第41行 输出0然后执行for循环 执行45航，输出0；

        //这时候再去执行定时器---》执行定时器的时候，有一个任务队列的情况，看谁的是你短，就先执行谁的；


        


    
    </script>
</body>

</html>