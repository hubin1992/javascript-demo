<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<title>Document</title>
	</head>
	<body>
		<script>
			// async就是generator的语法糖
			//await 如果后面是一个普通的对象，他就直接返回，或者直接执行，如果是一个promise函数，那么就按照eventloop的规则去执行
			async function fn() {
				//  async 就相当于genarator函数的*
				console.log(1);
				let a = await asyn2(); //await 就相当于 yieId
				console.log(4);
			}

			async function asyn2() {
				console.log(2);
			}
			fn().then(data => {
				console.log(data);
			});
			console.log(3);

			//async 返回值会是then或者catch的回调参数

			//错误处理
			//方式1
			async function main() {
				try {
					const val1 = await firstStep();
					const val2 = await secondStep(val1);
					const val3 = await thirdStep(val1, val2);

					console.log('Final: ', val3);
				} catch (err) {
					console.error(err);
				}
			}

			//方式2
			async function f() {
				await new Promise(function(resolve, reject) {
					throw new Error('出错了');
				});
			}

			f()
				.then(v => console.log(v))
				.catch(e => console.log(e));

			//使用await的注意点
			// 1. await后面的promise对象可能会reject的，所以我们应该把awit放到try里面执行
			async function testTry() {
				//这样使用比较好
				try {
					await new Promise((resovle, reject) => {
						throw new Error('出错了');
					});
				} catch (e) {
					console.log(e);
				}
			}

			//2. 如果多个await没有必然关联，可以同时执行
			// 写法1
			let [foo, bar] = await Promise.all([getfoo(), getbar()]);

			//写法2
			let getfoo = getfoo();
			let getbar = getbar();
			let foo = await getfoo;
			let bar = await getbar;

      //===================================
      //async函数的实现原理---> 暂时不想去打怪升级
      // 其实就是将 generator用函数包裹起来了
		</script>
	</body>
</html>
