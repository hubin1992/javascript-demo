<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<title>对象</title>
	</head>

	<body>
		<script>
			//obj中如果属性名和属性只相同，那么可以仅仅写一个，commenjs就比较适合这样来写

			//方法name的属性，可以返回的是函数名  ---> 我感觉实际编程中，这个应用不大

			//获取属性的描述对象 Object.getOwnPrototypeDescriptor(obj,attr)
			// enumerable: true 表示属性是可以操作的

      //surper 关键字  --- 》这个只有用在对象的方法中才会生效，用在其他地方会报错，他指向的是对象的原型

      //Object.getPrototypeOf(obj) ---我们获取对象的原型
      //Object.setPrototypeOf(obj,prototype) === obj.__proto__ = prototype ---我们设置对象的原型

			
			//============================================
			//属性的简写
			let ms = {};
			let getItem = key => (key in ms ? ms[key] : null);
			let setItem = (key, value) => {
				ms[key] = value;
			};
			let clear = () => {};
			// modules.exports = {
			// 	getItem,
			// 	setItem,
			// };
			//============================================
			//方法的name属性
			const person1 = {
				sayName() {},
			};
			console.log(person1.sayName.name); //sayName
			//============================================
			//获取对象的属性
			let test = {
				foo: 1,
			};
			console.log(Object.getOwnPropertyDescriptor(test, 'foo'));
			/* configurable: true;
			enumerable: true; 是否可枚举
			value: 1;
			writable: true; */
			//============================================
      //super 关键字
      const proto = {
        x:"hello",
        foo(){
          console.log(this.x)
        }
      }
      const protObj = {
        x:"world",
        foo(){
          super.foo()// Object.getPrototypeOf(this).foo||Object.getPrototypeOf(this).foo.call(this)
        }
      }
      Object.setPrototypeOf(protObj,proto)
      protObj.foo()


			//============================================

		</script>
	</body>
</html>
