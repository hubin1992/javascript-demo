<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<title>promise</title>
	</head>
	<body>
		<script>
			//简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息

			//Promise对象是一个构造函数，用来生成Promise实例。

			// let promise = new Promise((resolve,reject)=>{
			//   setTimeout(()=>{
			//     resolve(1)
			//   })
			// })

			//img 加载的实例
			function loadingImg(url) {
				return new Promise((resolve, reject) => {
					const img = new Image();
					img.onload = function() {
						resolve('加载成功');
					};
					img.onerror = function() {
						reject('路径错误');
					};
					img.src = url;

					document.body.appendChild(img);
				});
			}

			let p = loadingImg(
				'https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2394972844,3024358326&fm=26&gp=0.jpg'
			);

			p.then(
				data => {
					console.log(data);
				},
				err => {
					console.log(err);
				}
			);

			//ajax实际例
			function ajax(url) {
				return new Promise((reslve, reject) => {
					function change() {
						if (this.readystate != 4) {
							return;
						}
						if (this.state == 200) {
							resolve(this.response);
						} else {
							reject(new Error(statusText));
						}
					}

					const xml = new XMLHttpRequest();
					xml.open('get', url);
					xml.responseText = 'json';
					xml.setRequestHeader({ Accept: 'application/json' });
					xml.onreadystatechange = change;
					xml.send();
				});
			}

			//=======================================
			//Promise.prototype.then()
			//它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。

			//注意：then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。
			ajax('get/1.html')
				.then(data => {
					return ajax('a.html');
				})
				.then(
					data => {
						console.log(data);
					},
					err => {
						console.log(err);
					}
				);
			//=======================================
			//Promise.prototype.catch()
			//一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。
			//注意这个catch 可以捕获到所有的错误信息
			//catch 返回的也是Promise他也可以用链式写法
			ajax('/post/1.json')
				.then(function(post) {
					return getJSON(post.commentURL);
				})
				.then(function(comments) {
					// some code
				})
				.catch(function(error) {
					// 处理前面三个Promise产生的错误
				});
			//=======================================
			//Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
			//上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。

			//p的状态由p1、p2、p3决定，分成两种情况。

			//（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。

			//（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

			//下面是一个具体的例子。
			const a = [1, 2, 3, 4, 5].map(item => {
				return ajax(`post${item}.json`);
			});
			Promise.all(a)
				.then(function(posts) {
					// ...
				})
				.catch(function(reason) {
					// ...
				});

			//只有上面的6个ajax的方法都成功或者失败才会走then或者catch

			//=======================================
			//Promise.race(arr)
			// 这个方法和all正好相反，当arr中有一个执行完成了，那么他就走then或者catch的回调
			//Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。
			//=======================================
      //Promise.resolve() 将普通对象转换为promise对象
      Promise.reslve("foo") 
      //这两个是一样的写法
      new Promise((resolve,reject)=>{
        resolve("foo")
      })
      //Promise.reject() 这个也是将普通对象转换为promise对象
      Promise.reject("出错了")
      new Promise((resolve,reject)=>{
        reject("foo")
      })
        
			//=======================================
			//Promise.prototype.finally()
			//finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。
		</script>
	</body>
</html>
