<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        //原型继承---->不是拷贝只是改变了原型链的查找模式
        //子级继承了父级的所有属性，作为了子级别的公有的属性
        // function Fn(){
        //     this.x = 1000;
        // }
        // Fn.prototype.getX=function(){
        //     console.log(100)
        // }
        // function B(){}
        // //console.log(B.constructor)
        // B.prototype = new Fn;
        // B.prototype.constructor=B;//修改b的constrctor指向，如果不修改查到的是A;
        // //console.log(B.constructor)
        // var b = new Fn
        // console.log(b)

        //////////////////////////////////////////////
        //call继承
        //原理是把call当成一个普通的函数来执行，然后改变函数里面的this关键字的执行(直接拷贝过来了)
        //缺点：这样只能继承父类的私有属性
        // function Fn(){
        //     this.x = 1000;
        // };
        // Fn.prototype.getX=function(){
        //     console.log(100)
        // };
        // function B(){
        //     Fn.call(this)//构造函数的this指向的是他的实例
        // };
        // var b = new B();
        // console.log(b.x);//1000
        // console.log(b.getX);//undefined

        ///////////////////////////
        //冒充对象继承
        //创建一个父类的实例，因为这个实例是一个对象数据类型，然后我们可以来循环得到他的属性名和属性值；

        function Fn(){
            this.x = 1000;
        };
        Fn.prototype.getX=function(){
            console.log(100)
        };
        
        function B(){
            var temp = new Fn();
            for(var key in temp){
                this[key] = temp[key]
            }
        }
        var b  = new B()
        console.log(b.x);//1000       

        



    </script>
</body>
</html>